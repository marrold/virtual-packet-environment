# Docker Cheat Sheet

This isn't intended as a full guide, but just enough to get you going with the Virtual Packet Environment.

## What is Docker? 

Docker is an open source platform that can run applications in isolated "containers" - similar to virtualisation  but lighter weight. 

Applications and their configuration are baked into images and additional configuration can either be mounted as a file or supplied as environment variables.

They're easy to create, portable, and the isolation makes things like conflicting dependencies and running multiple instances of the same application easier.

## What is Docker Compose? 

Docker Compose is a tool that makes spinning up containers easier, as you can define multiple related containers and their relationships in a single file rather than individually starting them from the command line.

## How do I use it?

Start the containers defined in `docker-compose.yml` 

    docker compose up -d

Stop the containers defined in `docker-compose.yml` 
    
    docker compose down

Pull the latest versions of the images:

    docker compose pull

Show the running containers:

    docker ps

View the logs for a container:
     
    docker logs -f $container_name

## Firewalling / iptables

Docker hooks deeply into iptables and making changes without knowing what you're doing can block access or worse, lead to an insecure system.

If the machine you're running VPE on is behind your home router / firewall you're probably already protected and don't have to touch iptables. If you're using a hosted virtual machine use the firewalling tools provided by your hosting provider if they exist. Otherwise, read on...

First off, you don't want to be meddling with the `DOCKER` `FORWARD` `POSTROUTING` and `DOCKER-ISOLATION-*` chains. This includes accidentally flushing them with something like `iptables-restore`. If you do accidently touch these chains, restarting the docker daemon should restore them.

The good news is you *can* put rules into the `INPUT` chain. These protect services running directly on the host, such as SSH.

Rules that would traditionally go in the `FORWARD` chain can be placed into `DOCKER-USER`  chain instead. These take precedence over the rules generated by Docker.

### Example

To add persistent iptables rules, create an `if-pre-up` file:

    vim /etc/network/if-pre-up.d/iptables 
 
 Enter the following:
 
    #!/usr/bin/env bash
    /sbin/iptables-restore --noflush < /etc/iptables/rules.v4

Make it excutable:
    
    chmod +x /etc/network/if-pre-up.d/iptables

Create a v4 rules file:

    vim /etc/iptables/rules.v4
   
Add your rules, *something* like:

    *filter
    :INPUT DROP [0:0]
    :DOCKER-USER - [0:0]

    # Flush the chains we're updating
    -F INPUT
    -F DOCKER-USER

    # Allow established connections
    -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
    
    # Allow ICMP
    -A INPUT -p icmp -j ACCEPT
   
    # Allow SSH to Host
    -A INPUT -p tcp --dport 22 -j ACCEPT

    # Allow ESTABLISHED
    -A DOCKER-USER -m conntrack --ctstate RELATED,ESTABLISHED -j RETURN

    # Allow HTTP
    -A DOCKER-USER -p udp --dport 80 -j RETURN

    # Drop everything else arriving on public interface
    -A DOCKER-USER -i enp1s0 -j DROP

    COMMIT



 v6

    # Allow DHCPv6
    -A INPUT -m conntrack --ctstate NEW -m udp -p udp --dport 546 -d fe80::/64 -j ACCEPT

    # Allow ICMP
    -A INPUT -p ipv6-icmp -j ACCEPT
